
[
    {
        "id": "ai-p1-bfs",
        "title": "Program 1: Breadth First Search (BFS)",
        "language": "Python",
        "tags": ["bfs", "graph", "search"],
        "problem": "Aim: Write a Program to Implement Breadth First Search using Python.",
        "code": "from collections import deque\n\ndef bfs(graph, start_node):\n    \"\"\"Performs Breadth-First Search on a graph.\"\"\"\n    visited = set()\n    queue = deque([start_node])\n    traversal_order = []\n\n    while queue:\n        vertex = queue.popleft()\n        if vertex not in visited:\n            visited.add(vertex)\n            traversal_order.append(vertex)\n            # Add adjacent vertices to the queue\n            for neighbor in graph.get(vertex, []):\n                if neighbor not in visited:\n                    queue.append(neighbor)\n    \n    return traversal_order\n\n# Example Usage:\nif __name__ == '__main__':\n    # Define a graph as an adjacency list\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['A', 'D', 'E'],\n        'C': ['A', 'F'],\n        'D': ['B'],\n        'E': ['B', 'F'],\n        'F': ['C', 'E']\n    }\n\n    start_node = 'A'\n    print(f\"Graph: {graph}\")\n    print(f\"Starting BFS from node: {start_node}\")\n    \n    bfs_traversal = bfs(graph, start_node)\n    \n    print(f\"BFS Traversal Order: {' -> '.join(bfs_traversal)}\")"
    },
    {
        "id": "ai-p2-best-first",
        "title": "Program 2: Best First Search",
        "language": "Python",
        "tags": ["best-first", "heuristic", "graph"],
        "problem": "Aim: Write a program to implement Best First Searching Algorithm.",
        "code": "import heapq\n\ndef best_first_search(graph, start, goal, heuristic):\n    \"\"\"Performs Best-First Search on a graph.\"\"\"\n    visited = set()\n    # Priority queue stores tuples of (heuristic_value, node, path)\n    priority_queue = [(heuristic[start], start, [start])]\n    \n    while priority_queue:\n        # Get the node with the lowest heuristic value\n        h_value, current_node, path = heapq.heappop(priority_queue)\n        \n        if current_node in visited:\n            continue\n            \n        visited.add(current_node)\n        \n        # Goal found\n        if current_node == goal:\n            return path\n        \n        # Explore neighbors\n        for neighbor, cost in graph[current_node].items():\n            if neighbor not in visited:\n                heapq.heappush(priority_queue, (heuristic[neighbor], neighbor, path + [neighbor]))\n    \n    return None # Path not found\n\n# Example Usage:\nif __name__ == '__main__':\n    # Graph represented as an adjacency list with costs (not used in pure Best-First)\n    graph = {\n        'A': {'B': 1, 'C': 4},\n        'B': {'A': 1, 'D': 3, 'E': 5},\n        'C': {'A': 4, 'F': 2},\n        'D': {'B': 3},\n        'E': {'B': 5, 'F': 1},\n        'F': {'C': 2, 'E': 1, 'G': 5},\n        'G': {'F': 5}\n    }\n\n    # Heuristic values (straight-line distance to goal 'G')\n    heuristic = {\n        'A': 10, 'B': 8, 'C': 7, 'D': 6, 'E': 4, 'F': 2, 'G': 0\n    }\n\n    start_node = 'A'\n    goal_node = 'G'\n\n    print(f\"Starting from: {start_node}\")\n    print(f\"Goal: {goal_node}\")\n\n    path = best_first_search(graph, start_node, goal_node, heuristic)\n\n    if path:\n        print(f\"Path found: {' -> '.join(path)}\")\n    else:\n        print(\"Path not found.\")"
    },
    {
        "id": "ai-p3-dfs",
        "title": "Program 3: Depth First Search (DFS)",
        "language": "Python",
        "tags": ["dfs", "graph", "search"],
        "problem": "Aim: Write a Program to Implement Depth First Search using Python.",
        "code": "def dfs_recursive(graph, vertex, visited=None):\n    \"\"\"Performs Depth-First Search recursively.\"\"\"\n    if visited is None:\n        visited = set()\n    \n    visited.add(vertex)\n    traversal_order = [vertex]\n    \n    for neighbor in graph.get(vertex, []):\n        if neighbor not in visited:\n            traversal_order.extend(dfs_recursive(graph, neighbor, visited))\n            \n    return traversal_order\n\n# Example Usage:\nif __name__ == '__main__':\n    # Define a graph as an adjacency list\n    graph = {\n        'A': ['B', 'C'],\n        'B': ['D', 'E'],\n        'C': ['F'],\n        'D': [],\n        'E': ['F'],\n        'F': []\n    }\n\n    start_node = 'A'\n    print(f\"Graph: {graph}\")\n    print(f\"Starting DFS from node: {start_node}\")\n    \n    dfs_traversal = dfs_recursive(graph, start_node)\n    \n    print(f\"DFS Traversal Order: {' -> '.join(dfs_traversal)}\")"
    },
    {
        "id": "ai-p4-heuristic-search",
        "title": "Program 4: Heuristic (Hill Climbing) Search",
        "language": "Python",
        "tags": ["heuristic", "hill-climbing", "search"],
        "problem": "Aim: Write a program to implement the Heuristic Search using hill climbing.",
        "code": "def hill_climbing(graph, start, goal, heuristic):\n    \"\"\"Simple Hill Climbing algorithm.\"\"\"\n    current_node = start\n    path = [current_node]\n    \n    while current_node != goal:\n        neighbors = graph.get(current_node, {})\n        if not neighbors:\n            # No more moves possible\n            return path, False\n        \n        # Find the neighbor with the best (lowest) heuristic value\n        best_neighbor = None\n        min_h_value = heuristic[current_node]\n        \n        for neighbor in neighbors:\n            if heuristic[neighbor] < min_h_value:\n                min_h_value = heuristic[neighbor]\n                best_neighbor = neighbor\n        \n        if best_neighbor is None:\n            # Local minimum reached (stuck)\n            return path, False\n        \n        current_node = best_neighbor\n        path.append(current_node)\n        \n    return path, True # Goal reached\n\n# Example Usage:\nif __name__ == '__main__':\n    # Graph represented as an adjacency list\n    graph = {\n        'A': {'B', 'C'},\n        'B': {'D', 'E'},\n        'C': {'F'},\n        'D': {},\n        'E': {'F', 'G'},\n        'F': {'G'},\n        'G': {}\n    }\n\n    # Heuristic values (estimated distance to goal 'G')\n    heuristic = {\n        'A': 6, 'B': 5, 'C': 4, 'D': 3, 'E': 2, 'F': 1, 'G': 0\n    }\n\n    start_node = 'A'\n    goal_node = 'G'\n\n    print(f\"Starting Hill Climbing from: {start_node} to {goal_node}\")\n\n    path, success = hill_climbing(graph, start_node, goal_node, heuristic)\n\n    if success:\n        print(f\"Path found: {' -> '.join(path)}\")\n    else:\n        print(f\"Stuck at a local minimum. Path taken: {' -> '.join(path)}\")"
    },
    {
        "id": "ai-p5-astar-ao",
        "title": "Program 5: A* Algorithm",
        "language": "Python",
        "tags": ["a*", "heuristic", "graph", "shortest-path"],
        "problem": "Aim: Write a python program to implement A* algorithm to find the shortest path. (AO* is complex and often context-dependent, so this focuses on A*)",
        "code": "import heapq\n\ndef a_star_search(graph, start, goal, heuristic):\n    \"\"\"Performs A* search to find the shortest path.\"\"\"\n    # Priority queue: (f_cost, g_cost, node, path)\n    # f_cost = g_cost + h_cost\n    open_list = [(heuristic[start], 0, start, [start])]\n    closed_set = set()\n    g_costs = {node: float('inf') for node in graph}\n    g_costs[start] = 0\n    \n    while open_list:\n        f_cost, g_cost, current_node, path = heapq.heappop(open_list)\n        \n        if current_node in closed_set:\n            continue\n            \n        closed_set.add(current_node)\n        \n        if current_node == goal:\n            return path, g_cost\n            \n        for neighbor, cost in graph[current_node].items():\n            tentative_g_cost = g_cost + cost\n            \n            if tentative_g_cost < g_costs[neighbor]:\n                g_costs[neighbor] = tentative_g_cost\n                h_cost = heuristic[neighbor]\n                f_cost = tentative_g_cost + h_cost\n                heapq.heappush(open_list, (f_cost, tentative_g_cost, neighbor, path + [neighbor]))\n                \n    return None, float('inf') # Path not found\n\n# Example Usage:\nif __name__ == '__main__':\n    graph = {\n        'A': {'B': 1, 'C': 4},\n        'B': {'A': 1, 'D': 3, 'E': 5},\n        'C': {'A': 4, 'F': 2},\n        'D': {'B': 3},\n        'E': {'B': 5, 'F': 1},\n        'F': {'C': 2, 'E': 1, 'G': 5},\n        'G': {'F': 5}\n    }\n\n    heuristic = {\n        'A': 10, 'B': 8, 'C': 7, 'D': 6, 'E': 4, 'F': 2, 'G': 0\n    }\n\n    start_node = 'A'\n    goal_node = 'G'\n\n    print(f\"Running A* from {start_node} to {goal_node}\")\n    path, cost = a_star_search(graph, start_node, goal_node, heuristic)\n\n    if path:\n        print(f\"Shortest path found: {' -> '.join(path)}\")\n        print(f\"Total cost: {cost}\")\n    else:\n        print(\"Path not found.\")"
    },
    {
        "id": "ai-p6-water-jug",
        "title": "Program 6: Water Jug Problem",
        "language": "Python",
        "tags": ["water-jug", "state-space", "search"],
        "problem": "Aim: Write a Program to Implement Water-Jug problem using Python.",
        "code": "from collections import deque\n\ndef water_jug_problem(capacity_x, capacity_y, target):\n    \"\"\"Solves the Water Jug problem using BFS.\"\"\"\n    # The state is represented by (amount_in_x, amount_in_y)\n    start_state = (0, 0)\n    # Queue for BFS stores (state, path)\n    queue = deque([(start_state, [start_state])])\n    visited = {start_state}\n\n    while queue:\n        (current_x, current_y), path = queue.popleft()\n\n        # Check if we have reached the target\n        if current_x == target or current_y == target:\n            return path\n\n        # Possible next states\n        next_states = []\n        # 1. Fill jug X\n        next_states.append(((capacity_x, current_y), path + [(capacity_x, current_y)]))\n        # 2. Fill jug Y\n        next_states.append(((current_x, capacity_y), path + [(current_x, capacity_y)]))\n        # 3. Empty jug X\n        next_states.append(((0, current_y), path + [(0, current_y)]))\n        # 4. Empty jug Y\n        next_states.append(((current_x, 0), path + [(current_x, 0)]))\n        # 5. Pour X to Y\n        pour_amount = min(current_x, capacity_y - current_y)\n        next_states.append(((current_x - pour_amount, current_y + pour_amount), path + [(current_x - pour_amount, current_y + pour_amount)]))\n        # 6. Pour Y to X\n        pour_amount = min(current_y, capacity_x - current_x)\n        next_states.append(((current_x + pour_amount, current_y - pour_amount), path + [(current_x + pour_amount, current_y - pour_amount)]))\n\n        for state, new_path in next_states:\n            if state not in visited:\n                visited.add(state)\n                queue.append((state, new_path))\n\n    return None # No solution found\n\n# Example Usage:\nif __name__ == '__main__':\n    jug1_capacity = 4\n    jug2_capacity = 3\n    target_amount = 2\n\n    print(f\"Capacities: Jug1={jug1_capacity}L, Jug2={jug2_capacity}L\")\n    print(f\"Target amount: {target_amount}L\")\n\n    solution_path = water_jug_problem(jug1_capacity, jug2_capacity, target_amount)\n\n    if solution_path:\n        print(\"\\nSolution found!\")\n        for i, state in enumerate(solution_path):\n            print(f\"Step {i}: Jug1={state[0]}L, Jug2={state[1]}L\")\n    else:\n        print(\"\\nNo solution found.\")"
    },
    {
        "id": "ai-p7-alpha-beta",
        "title": "Program 7: Alpha-Beta Pruning",
        "language": "Python",
        "tags": ["alpha-beta", "minimax", "game-tree"],
        "problem": "Aim: Write a Program to Implement Alpha-Beta Pruning using Python.",
        "code": "import math\n\nMAX, MIN = 1000, -1000\n\ndef minimax_alpha_beta(depth, node_index, is_maximizing_player, values, alpha, beta):\n    \"\"\"Minimax algorithm with Alpha-Beta Pruning.\"\"\"\n    # Base case: if we are at a leaf node\n    if depth == int(math.log(len(values), 2)):\n        return values[node_index]\n\n    if is_maximizing_player:\n        best_value = MIN\n        for i in range(2):\n            val = minimax_alpha_beta(depth + 1, node_index * 2 + i, False, values, alpha, beta)\n            best_value = max(best_value, val)\n            alpha = max(alpha, best_value)\n            # Alpha-Beta Pruning\n            if beta <= alpha:\n                print(f\"(Pruning at MAX level: alpha={alpha}, beta={beta})\")\n                break\n        return best_value\n    else: # Minimizing player\n        best_value = MAX\n        for i in range(2):\n            val = minimax_alpha_beta(depth + 1, node_index * 2 + i, True, values, alpha, beta)\n            best_value = min(best_value, val)\n            beta = min(beta, best_value)\n            # Alpha-Beta Pruning\n            if beta <= alpha:\n                print(f\"(Pruning at MIN level: alpha={alpha}, beta={beta})\")\n                break\n        return best_value\n\n# Example Usage:\nif __name__ == '__main__':\n    # Leaf node values for a game tree of depth 3\n    # This tree has 2^3 = 8 leaf nodes\n    leaf_values = [3, 5, 2, 9, 12, 5, 23, 23]\n    print(f\"Leaf values: {leaf_values}\")\n    \n    optimal_value = minimax_alpha_beta(0, 0, True, leaf_values, MIN, MAX)\n    print(f\"\\nThe optimal value for the maximizing player is: {optimal_value}\")"
    },
    {
        "id": "ai-p8-8queens",
        "title": "Program 8: 8-Queens Problem",
        "language": "Python",
        "tags": ["8-queens", "backtracking"],
        "problem": "Aim: Write a Program to implement 8-Queens Problem using Python.",
        "code": "class NQueens:\n    def __init__(self, n):\n        self.n = n\n        self.board = [[0] * n for _ in range(n)]\n        self.solutions = []\n\n    def is_safe(self, row, col):\n        # Check this row on left side\n        for i in range(col):\n            if self.board[row][i] == 1:\n                return False\n        \n        # Check upper diagonal on left side\n        for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n            if self.board[i][j] == 1:\n                return False\n        \n        # Check lower diagonal on left side\n        for i, j in zip(range(row, self.n, 1), range(col, -1, -1)):\n            if self.board[i][j] == 1:\n                return False\n        \n        return True\n\n    def solve_util(self, col):\n        # Base case: If all queens are placed\n        if col >= self.n:\n            # Store the solution\n            solution = [row[:] for row in self.board]\n            self.solutions.append(solution)\n            return True\n\n        res = False\n        for i in range(self.n):\n            if self.is_safe(i, col):\n                self.board[i][col] = 1\n                # Recur to place rest of the queens\n                res = self.solve_util(col + 1) or res\n                # If placing queen in board[i][col] doesn't lead to a solution,\n                # then remove queen from board[i][col] (backtrack)\n                self.board[i][col] = 0\n        \n        return res\n\n    def solve(self):\n        self.solutions = []\n        self.solve_util(0)\n        return self.solutions\n\ndef print_solution(solution):\n    for row in solution:\n        print(\" \".join(\"Q\" if cell == 1 else \".\" for cell in row))\n    print(\"\\n\")\n\n# Example Usage:\nif __name__ == '__main__':\n    n = 8\n    print(f\"Solving the {n}-Queens problem...\\n\")\n    solver = NQueens(n)\n    solutions = solver.solve()\n\n    if solutions:\n        print(f\"Found {len(solutions)} solutions.\")\n        print(\"Showing the first solution:\\n\")\n        print_solution(solutions[0])\n    else:\n        print(\"No solution found.\")"
    },
    {
        "id": "ai-p9-default-meeting",
        "title": "Program 9: Meeting Scheduling with Default Reasoning",
        "language": "Python",
        "tags": ["default-reasoning", "scheduling"],
        "problem": "Aim: Write a program to schedule a meeting among 5 busy people using Default Reasoning so that the output gives the time, place and day of the meeting.",
        "code": "import random\n\nclass Person:\n    def __init__(self, name, available_times):\n        self.name = name\n        # available_times is a dictionary: {'Day': [start_hour, end_hour]}\n        self.available_times = available_times\n\n    def is_available(self, day, hour):\n        if day in self.available_times:\n            start, end = self.available_times[day]\n            return start <= hour < end\n        return False\n\nclass Scheduler:\n    def __init__(self, people, meeting_duration=1):\n        self.people = people\n        self.duration = meeting_duration\n        self.days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n        self.hours = range(9, 17) # 9 AM to 5 PM\n        self.default_place = 'Conference Room A'\n\n    def find_common_slot(self):\n        for day in self.days:\n            for hour in self.hours:\n                # Check if all people are available for the duration\n                all_available = True\n                for person in self.people:\n                    if not person.is_available(day, hour):\n                        all_available = False\n                        break\n                \n                if all_available:\n                    return {'day': day, 'time': f\"{hour}:00\", 'place': self.default_place}\n        return None\n\n# Example Usage\nif __name__ == '__main__':\n    # Define people and their available schedules\n    people = [\n        Person('Alice', {'Monday': [9, 12], 'Wednesday': [13, 17]}),\n        Person('Bob', {'Monday': [10, 14], 'Friday': [9, 12]}),\n        Person('Charlie', {'Monday': [9, 11], 'Tuesday': [14, 16]}),\n        Person('Diana', {'Monday': [10, 17]}),\n        Person('Eve', {'Monday': [9, 13], 'Thursday': [11, 15]})\n    ]\n\n    print(\"Attempting to schedule a 1-hour meeting for 5 people...\")\n    for person in people:\n        print(f\"- {person.name}: {person.available_times}\")\n\n    scheduler = Scheduler(people)\n    meeting_slot = scheduler.find_common_slot()\n\n    if meeting_slot:\n        print(\"\\n--- Meeting Scheduled! ---\")\n        print(f\"Day: {meeting_slot['day']}\")\n        print(f\"Time: {meeting_slot['time']}\")\n        print(f\"Place: {meeting_slot['place']} (Default)\")\n    else:\n        print(\"\\n--- No Common Slot Found ---\")\n        print(\"Could not find a time when everyone is available.\")"
    },
    {
        "id": "ai-p10-unification",
        "title": "Program 10: Unification Algorithm",
        "language": "Python",
        "tags": ["unification", "logic"],
        "problem": "Aim: Write a program to implement the Unification algorithm.",
        "code": "def unify(x, y, theta):\n    \"\"\"Unifies expressions x and y with substitution theta.\"\"\"\n    if theta is None:\n        return None\n    elif x == y:\n        return theta\n    elif isinstance(x, str) and x.islower(): # x is a variable\n        return unify_var(x, y, theta)\n    elif isinstance(y, str) and y.islower(): # y is a variable\n        return unify_var(y, x, theta)\n    elif isinstance(x, list) and isinstance(y, list) and len(x) == len(y):\n        if not x: # Both are empty lists\n            return theta \n        return unify(x[1:], y[1:], unify(x[0], y[0], theta))\n    else:\n        return None\n\ndef unify_var(var, x, theta):\n    if var in theta:\n        return unify(theta[var], x, theta)\n    elif x in theta:\n        return unify(var, theta[x], theta)\n    # elif occur_check(var, x, theta):  # Advanced: prevent infinite recursion like X = f(X)\n    #     return None\n    else:\n        new_theta = theta.copy()\n        new_theta[var] = x\n        return new_theta\n\n# Helper for occur_check (optional but good practice)\n# def occur_check(var, x, theta):\n#     if var == x: return True\n#     elif isinstance(x, str) and x.islower() and x in theta: return occur_check(var, theta[x], theta)\n#     elif isinstance(x, list): return any(occur_check(var, item, theta) for item in x)\n#     return False\n\n# Example Usage\nif __name__ == '__main__':\n    # Expressions are represented as lists\n    # Variables are lowercase strings, constants are uppercase strings\n    e1 = ['P', 'x', ['f', 'A']]\n    e2 = ['P', 'B', 'y']\n    initial_substitution = {}\n\n    print(f\"Expression 1: {e1}\")\n    print(f\"Expression 2: {e2}\")\n\n    result = unify(e1, e2, initial_substitution)\n\n    if result is not None:\n        print(\"\\nUnification successful!\")\n        print(f\"Substitution (MGU): {result}\")\n    else:\n        print(\"\\nUnification failed.\")\n\n    # Another example\n    print(\"\\n--------------------\\n\")\n    e3 = ['knows', 'John', 'x']\n    e4 = ['knows', 'y', 'Bill']\n    print(f\"Expression 3: {e3}\")\n    print(f\"Expression 4: {e4}\")\n    result2 = unify(e3, e4, {})\n    print(f\"Unification result: {result2}\")"
    },
    {
        "id": "ai-p11-kb-system",
        "title": "Program 11: Simple Knowledge Base System",
        "language": "Python",
        "tags": ["knowledge-base", "rules", "inference"],
        "problem": "Aim: Develop a simple knowledge base system consisting of facts and rules for a specialized domain (e.g., family relationships).",
        "code": "class KnowledgeBase:\n    def __init__(self):\n        self.facts = set()\n        self.rules = []\n\n    def add_fact(self, fact):\n        \"\"\"Adds a fact to the knowledge base. A fact is a tuple.\"\"\"\n        self.facts.add(fact)\n\n    def add_rule(self, antecedents, consequent):\n        \"\"\"Adds a rule. A rule is a list of antecedent facts and one consequent fact.\"\"\"\n        self.rules.append((antecedents, consequent))\n\n    def query(self, query_fact):\n        \"\"\"Checks if a fact can be inferred from the KB.\"\"\"\n        if query_fact in self.facts:\n            return True\n        \n        # Apply forward chaining to infer new facts\n        inferred_facts = set()\n        while True:\n            new_facts_found = False\n            for antecedents, consequent in self.rules:\n                # Check if all antecedents of a rule are known\n                all_antecedents_known = True\n                for antecedent in antecedents:\n                    if antecedent not in self.facts and antecedent not in inferred_facts:\n                        all_antecedents_known = False\n                        break\n                \n                if all_antecedents_known and consequent not in self.facts and consequent not in inferred_facts:\n                    print(f\"Inferred: {consequent}\")\n                    inferred_facts.add(consequent)\n                    new_facts_found = True\n                    # Check if the newly inferred fact is our query\n                    if consequent == query_fact:\n                        return True\n            \n            if not new_facts_found:\n                break # No new facts can be inferred\n            \n            self.facts.update(inferred_facts)\n            inferred_facts.clear()\n\n        return False\n\n# Example Usage\nif __name__ == '__main__':\n    kb = KnowledgeBase()\n\n    # --- Define Facts (Family Relationships) ---\n    # (relation, person1, person2)\n    kb.add_fact(('parent', 'John', 'Sue'))\n    kb.add_fact(('parent', 'John', 'Tom'))\n    kb.add_fact(('parent', 'Mary', 'Sue'))\n    kb.add_fact(('parent', 'Mary', 'Tom'))\n    kb.add_fact(('male', 'John'))\n    kb.add_fact(('male', 'Tom'))\n    kb.add_fact(('female', 'Mary'))\n    kb.add_fact(('female', 'Sue'))\n\n    # --- Define Rules ---\n    # Rule 1: father(X, Y) :- parent(X, Y), male(X)\n    kb.add_rule([('parent', 'X', 'Y'), ('male', 'X')], ('father', 'X', 'Y'))\n    # Rule 2: mother(X, Y) :- parent(X, Y), female(X)\n    kb.add_rule([('parent', 'X', 'Y'), ('female', 'X')], ('mother', 'X', 'Y'))\n\n    print(\"Initial Facts:\", kb.facts)\n    print(\"--- Queries ---\")\n\n    # --- Query the Knowledge Base ---\n    query1 = ('father', 'John', 'Sue')\n    print(f\"\\nQuerying: Is John the father of Sue? {query1}\")\n    print(f\"Result: {kb.query(query1)}\")\n\n    query2 = ('mother', 'Mary', 'Tom')\n    print(f\"\\nQuerying: Is Mary the mother of Tom? {query2}\")\n    print(f\"Result: {kb.query(query2)}\")\n    \n    query3 = ('father', 'Mary', 'Sue')\n    print(f\"\\nQuerying: Is Mary the father of Sue? {query3}\")\n    print(f\"Result: {kb.query(query3)}\")"
    },
    {
        "id": "ai-p12-8puzzle",
        "title": "Program 12: 8-Puzzle Using Different Heuristics",
        "language": "Python",
        "tags": ["8-puzzle", "a*", "heuristic"],
        "problem": "Aim: Write a program to implement 8 puzzle problem using different heuristics (Misplaced Tiles and Manhattan Distance).",
        "code": "import heapq\n\nclass PuzzleNode:\n    def __init__(self, state, parent=None, move=None, g=0, h=0):\n        self.state = state\n        self.parent = parent\n        self.move = move\n        self.g = g  # Cost from start to current node\n        self.h = h  # Heuristic cost (estimated cost to goal)\n\n    @property\n    def f(self):\n        return self.g + self.h\n\n    def __lt__(self, other):\n        return self.f < other.f\n\ndef get_blank_pos(state):\n    for r in range(3):\n        for c in range(3):\n            if state[r][c] == 0:\n                return r, c\n    return None, None\n\ndef get_moves(state):\n    r, c = get_blank_pos(state)\n    moves = []\n    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < 3 and 0 <= nc < 3:\n            new_state = [row[:] for row in state]\n            new_state[r][c], new_state[nr][nc] = new_state[nr][nc], new_state[r][c]\n            moves.append(new_state)\n    return moves\n\ndef h_misplaced_tiles(state, goal_state):\n    misplaced = 0\n    for r in range(3):\n        for c in range(3):\n            if state[r][c] != goal_state[r][c] and state[r][c] != 0:\n                misplaced += 1\n    return misplaced\n\ndef h_manhattan_distance(state, goal_state):\n    distance = 0\n    for r1 in range(3):\n        for c1 in range(3):\n            tile = state[r1][c1]\n            if tile != 0:\n                for r2 in range(3):\n                    for c2 in range(3):\n                        if goal_state[r2][c2] == tile:\n                            distance += abs(r1 - r2) + abs(c1 - c2)\n                            break\n    return distance\n\ndef solve_8_puzzle(start_state, goal_state, heuristic_func):\n    start_node = PuzzleNode(start_state, g=0, h=heuristic_func(start_state, goal_state))\n    open_list = [start_node]\n    closed_set = set()\n\n    while open_list:\n        current_node = heapq.heappop(open_list)\n        \n        if current_node.state == goal_state:\n            path = []\n            while current_node:\n                path.append(current_node.state)\n                current_node = current_node.parent\n            return path[::-1]\n\n        closed_set.add(tuple(map(tuple, current_node.state)))\n\n        for move_state in get_moves(current_node.state):\n            if tuple(map(tuple, move_state)) in closed_set:\n                continue\n\n            g = current_node.g + 1\n            h = heuristic_func(move_state, goal_state)\n            neighbor_node = PuzzleNode(move_state, parent=current_node, g=g, h=h)\n            heapq.heappush(open_list, neighbor_node)\n            \n    return None # No solution found\n\ndef print_puzzle(state):\n    for row in state:\n        print(\" \".join(str(tile) if tile != 0 else '_' for tile in row))\n    print()\n\n# Example Usage\nif __name__ == '__main__':\n    start_state = [[1, 2, 3], [0, 4, 6], [7, 5, 8]]\n    goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    print(\"Start State:\")\n    print_puzzle(start_state)\n    print(\"Goal State:\")\n    print_puzzle(goal_state)\n\n    print(\"\\n--- Solving with Misplaced Tiles Heuristic ---\")\n    solution_misplaced = solve_8_puzzle(start_state, goal_state, h_misplaced_tiles)\n    if solution_misplaced:\n        print(f\"Solution found in {len(solution_misplaced) - 1} moves.\")\n    else:\n        print(\"No solution found.\")\n\n    print(\"\\n--- Solving with Manhattan Distance Heuristic ---\")\n    solution_manhattan = solve_8_puzzle(start_state, goal_state, h_manhattan_distance)\n    if solution_manhattan:\n        print(f\"Solution found in {len(solution_manhattan) - 1} moves.\")\n        # for i, state in enumerate(solution_manhattan):\n        #     print(f\"Move {i}:\")\n        #     print_puzzle(state)\n    else:\n        print(\"No solution found.\")"
    }
]

    