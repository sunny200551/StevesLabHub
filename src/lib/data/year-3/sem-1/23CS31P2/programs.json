
[
    {
        "id": "cn-1",
        "title": "1. Framing Methods",
        "problem": "Implement the data link layer framing methods: character count, character stuffing, and bit stuffing.",
        "language": "python",
        "tags": ["Framing", "Data Link"],
        "code": "def character_count_framing(data, frame_size):\n    \"\"\"Frames data using character count.\"\"\"\n    frames = []\n    i = 0\n    while i < len(data):\n        frame = str(frame_size) + data[i:i + frame_size - 1]\n        frames.append(frame)\n        i += frame_size - 1\n    return frames\n\ndef character_stuffing(data, flag, escape):\n    \"\"\"Frames data using character stuffing.\"\"\"\n    stuffed_data = \"\"\n    for char in data:\n        if char == flag or char == escape:\n            stuffed_data += escape + char\n        else:\n            stuffed_data += char\n    return flag + stuffed_data + flag\n\ndef bit_stuffing(data):\n    \"\"\"Frames data using bit stuffing.\"\"\"\n    # Assumes data is a string of '0's and '1's\n    stuffed_data = data.replace('11111', '111110')\n    flag = '01111110'\n    return flag + stuffed_data + flag\n\n# Example Usage:\nif __name__ == '__main__':\n    original_data_text = \"HelloNetworkLayer\"\n    original_data_bits = \"1101011111010111111010111111110\"\n    \n    print(f\"Original Text Data: {original_data_text}\")\n    print(f\"Original Bit Data: {original_data_bits}\\n\")\n\n    # --- Character Count Framing ---\n    print(\"--- Character Count Framing (Frame Size = 5) ---\")\n    char_count_frames = character_count_framing(original_data_text, 5)\n    print(f\"Framed Data: {char_count_frames}\\n\")\n\n    # --- Character Stuffing ---\n    print(\"--- Character Stuffing (Flag='F', Escape='E') ---\")\n    data_with_flags = \"FDataEWithFFlags\"\n    print(f\"Data to stuff: {data_with_flags}\")\n    stuffed_char_frame = character_stuffing(data_with_flags, 'F', 'E')\n    print(f\"Stuffed Frame: {stuffed_char_frame}\\n\")\n    \n    # --- Bit Stuffing ---\n    print(\"--- Bit Stuffing ---\")\n    print(f\"Data to stuff: {original_data_bits}\")\n    stuffed_bit_frame = bit_stuffing(original_data_bits)\n    print(f\"Stuffed Frame: {stuffed_bit_frame}\")"
    },
    {
        "id": "cn-2",
        "title": "2. CRC Computation",
        "problem": "Write a program to compute CRC (Cyclic Redundancy Check) code for a given data and generator polynomial.",
        "language": "python",
        "tags": ["CRC", "Error Detection"],
        "code": "def xor(a, b):\n    \"\"\"Helper function to perform XOR on two binary strings.\"\"\"\n    result = []\n    for i in range(1, len(b)):\n        if a[i] == b[i]:\n            result.append('0')\n        else:\n            result.append('1')\n    return ''.join(result)\n\ndef crc_division(dividend, divisor):\n    \"\"\"Performs modulo-2 division for CRC.\"\"\"\n    pick = len(divisor)\n    tmp = dividend[0: pick]\n\n    while pick < len(dividend):\n        if tmp[0] == '1':\n            tmp = xor(divisor, tmp) + dividend[pick]\n        else:\n            tmp = xor('0'*pick, tmp) + dividend[pick]\n        pick += 1\n\n    if tmp[0] == '1':\n        tmp = xor(divisor, tmp)\n    else:\n        tmp = xor('0'*pick, tmp)\n\n    return tmp\n\ndef compute_crc(data, generator):\n    \"\"\"Computes the CRC code for data and a generator polynomial.\"\"\"\n    generator_len = len(generator)\n    # Append n-1 zeros to the data, where n is the length of the generator\n    appended_data = data + '0'*(generator_len - 1)\n    \n    remainder = crc_division(appended_data, generator)\n    \n    # The CRC code is the remainder\n    codeword = data + remainder\n    return remainder, codeword\n\n# Example Usage:\nif __name__ == '__main__':\n    dataword = \"100100\"\n    # Using CRC-8-ATM (x^8 + x^2 + x + 1) which is 100000111 in binary\n    generator_poly = \"100000111\"\n    \n    print(f\"Dataword: {dataword}\")\n    print(f\"Generator Polynomial: {generator_poly}\\n\")\n    \n    crc_remainder, transmitted_codeword = compute_crc(dataword, generator_poly)\n    \n    print(f\"CRC Remainder: {crc_remainder}\")\n    print(f\"Transmitted Codeword (Data + CRC): {transmitted_codeword}\\n\")\n    \n    # --- Error Checking Example ---\n    print(\"--- Verifying at Receiver ---\")\n    # Simulate receiving the correct codeword\n    received_codeword = transmitted_codeword\n    receiver_remainder = crc_division(received_codeword, generator_poly)\n    print(f\"Received: {received_codeword}\")\n    print(f\"Remainder after division: {receiver_remainder}\")\n    if '1' not in receiver_remainder:\n        print(\"Result: No error detected.\")\n    else:\n        print(\"Result: Error detected.\")"
    },
    {
        "id": "cn-3",
        "title": "3. Sliding Window (Go-Back-N)",
        "problem": "Implement a simulation of the Go-Back-N sliding window protocol.",
        "language": "python",
        "tags": ["Flow Control", "Sliding Window"],
        "code": "import time\nimport random\n\ndef go_back_n_simulation(num_frames, window_size):\n    \"\"\"Simulates the Go-Back-N protocol.\"\"\"\n    \n    sender_buffer = list(range(num_frames))\n    receiver_buffer = []\n    \n    base = 0\n    next_seq_num = 0\n    expected_seq_num = 0\n    \n    print(f\"Starting Go-Back-N with Window Size = {window_size} and {num_frames} frames.\\n\")\n\n    while base < num_frames:\n        # --- Sender Side ---\n        while next_seq_num < base + window_size and next_seq_num < num_frames:\n            print(f\"[Sender] Sending frame {sender_buffer[next_seq_num]}\")\n            # Simulate transmission\n            time.sleep(0.5)\n            next_seq_num += 1\n        \n        # --- Receiver Side & ACK Simulation ---\n        # Simulate a random ACK being received\n        # In a real scenario, this would be asynchronous\n        ack_to_receive = random.randint(base, next_seq_num - 1)\n        is_lost = random.random() < 0.2 # 20% chance of ACK loss or error\n\n        if is_lost and ack_to_receive > base:\n            print(f\"\\n[Network] ACK for frame {ack_to_receive} was lost or corrupted!\")\n            print(f\"[Sender] Timeout! Resending window from base {base}.\\n\")\n            time.sleep(1)\n            next_seq_num = base # Reset next_seq_num to start re-sending\n            continue\n\n        # Successfully received frames up to ack_to_receive\n        for i in range(expected_seq_num, ack_to_receive + 1):\n            if i < num_frames:\n                print(f\"[Receiver] Received frame {i} successfully.\")\n                receiver_buffer.append(sender_buffer[i])\n                expected_seq_num += 1\n        \n        print(f\"[Receiver] Sending cumulative ACK for frame {ack_to_receive}.\")\n        print(f\"[Sender] Received ACK for frame {ack_to_receive}. Sliding window.\")\n        \n        base = ack_to_receive + 1\n        print(f\"[Sender] New window base is {base}.\\n\")\n        time.sleep(1)\n\n    print(\"\\nAll frames transmitted successfully.\")\n    print(f\"Sender Buffer: {sender_buffer}\")\n    print(f\"Receiver Buffer: {receiver_buffer}\")\n    print(f\"Buffers match: {sender_buffer == receiver_buffer}\")\n\n# Example Usage\nif __name__ == '__main__':\n    NUMBER_OF_FRAMES = 10\n    WINDOW_SIZE = 4\n    go_back_n_simulation(NUMBER_OF_FRAMES, WINDOW_SIZE)"
    },
    {
        "id": "cn-4",
        "title": "4. Dijkstra’s Algorithm",
        "problem": "Implement Dijkstra’s algorithm to compute the shortest path through a network.",
        "language": "python",
        "tags": ["Routing", "Dijkstra"],
        "code": "import heapq\n\ndef dijkstra(graph, start_node):\n    \"\"\"Finds the shortest path from a start node to all other nodes in a weighted graph.\"\"\"\n    # Dictionary to store the shortest distance from start_node to every other node\n    distances = {node: float('infinity') for node in graph}\n    distances[start_node] = 0\n    \n    # Priority queue to hold (distance, node)\n    priority_queue = [(0, start_node)]\n    \n    # Dictionary to store the path\n    previous_nodes = {node: None for node in graph}\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        # If we have found a shorter path already, skip\n        if current_distance > distances[current_node]:\n            continue\n            \n        # Explore neighbors\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            \n            # If we found a shorter path to the neighbor\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                previous_nodes[neighbor] = current_node\n                heapq.heappush(priority_queue, (distance, neighbor))\n                \n    return distances, previous_nodes\n\ndef get_path(previous_nodes, start_node, target_node):\n    path = []\n    node = target_node\n    while node is not None:\n        path.append(node)\n        node = previous_nodes[node]\n    path = path[::-1]\n    if path[0] == start_node:\n        return path\n    return None\n\n# Example Usage\nif __name__ == '__main__':\n    # Network represented as a graph (adjacency list)\n    network_graph = {\n        'A': {'B': 1, 'C': 4},\n        'B': {'A': 1, 'C': 2, 'D': 5},\n        'C': {'A': 4, 'B': 2, 'D': 1},\n        'D': {'B': 5, 'C': 1, 'E': 3},\n        'E': {'D': 3}\n    }\n    \n    start = 'A'\n    distances, previous = dijkstra(network_graph, start)\n    \n    print(f\"Shortest paths from node '{start}':\\n\")\n    for node, distance in distances.items():\n        path = get_path(previous, start, node)\n        path_str = ' -> '.join(path) if path else 'N/A'\n        print(f\"To {node}: Distance = {distance}, Path = {path_str}\")"
    },
    {
        "id": "cn-5",
        "title": "5. Broadcast Tree (Spanning Tree)",
        "problem": "Obtain a broadcast tree (minimum spanning tree) for a subnet of hosts using Prim's algorithm.",
        "language": "python",
        "tags": ["Subnet", "Broadcast", "MST"],
        "code": "import heapq\n\ndef prims_mst(graph, start_node):\n    \"\"\"Generates a Minimum Spanning Tree (broadcast tree) using Prim's algorithm.\"\"\"\n    mst = []\n    visited = {start_node}\n    # Priority queue stores (weight, from_node, to_node)\n    edges = []\n    for to_node, weight in graph[start_node].items():\n        heapq.heappush(edges, (weight, start_node, to_node))\n    \n    total_weight = 0\n    \n    while edges and len(mst) < len(graph) - 1:\n        weight, from_node, to_node = heapq.heappop(edges)\n        \n        if to_node not in visited:\n            visited.add(to_node)\n            mst.append((from_node, to_node, weight))\n            total_weight += weight\n            \n            for next_node, next_weight in graph[to_node].items():\n                if next_node not in visited:\n                    heapq.heappush(edges, (next_weight, to_node, next_node))\n                    \n    return mst, total_weight\n\n# Example Usage\nif __name__ == '__main__':\n    # Subnet represented as a weighted, undirected graph\n    subnet = {\n        'A': {'B': 2, 'D': 3},\n        'B': {'A': 2, 'C': 3, 'D': 5, 'E': 2},\n        'C': {'B': 3, 'E': 4},\n        'D': {'A': 3, 'B': 5, 'E': 1},\n        'E': {'B': 2, 'C': 4, 'D': 1}\n    }\n    \n    start_host = 'A'\n    print(f\"Building Broadcast Tree from host '{start_host}'...\\n\")\n    \n    broadcast_tree, total_cost = prims_mst(subnet, start_host)\n    \n    print(\"Edges in the Broadcast Tree (MST):\")\n    for from_node, to_node, weight in broadcast_tree:\n        print(f\"  {from_node} --({weight})--> {to_node}\")\n        \n    print(f\"\\nTotal cost of the broadcast tree: {total_cost}\")"
    },
    {
        "id": "cn-6",
        "title": "6. Distance Vector Routing",
        "problem": "Implement distance vector routing algorithm for obtaining routing tables.",
        "language": "python",
        "tags": ["Routing", "DVR"],
        "code": "def distance_vector_routing(graph):\n    \"\"\"Simulates the Distance Vector Routing algorithm (Bellman-Ford).\"\"\"\n    nodes = list(graph.keys())\n    # Initialize routing tables: {destination: (next_hop, cost)}\n    routing_tables = {node: {dest: (dest if dest == node else None, float('inf')) for dest in nodes} for node in nodes}\n    \n    # Set direct link costs\n    for node, neighbors in graph.items():\n        routing_tables[node][node] = (node, 0)\n        for neighbor, cost in neighbors.items():\n            routing_tables[node][neighbor] = (neighbor, cost)\n\n    # Iteratively share and update tables\n    for _ in range(len(nodes) - 1): # N-1 iterations for convergence\n        updated = False\n        for node in nodes:\n            for dest in nodes:\n                # Current best path from node to dest\n                current_next_hop, current_cost = routing_tables[node][dest]\n\n                # Check paths via neighbors\n                for neighbor in graph[node]:\n                    cost_to_neighbor = graph[node][neighbor]\n                    # Cost of neighbor's path to destination\n                    cost_neighbor_to_dest = routing_tables[neighbor][dest][1]\n                    \n                    new_cost = cost_to_neighbor + cost_neighbor_to_dest\n\n                    if new_cost < current_cost:\n                        routing_tables[node][dest] = (neighbor, new_cost)\n                        updated = True\n        if not updated:\n            break # Converged early\n            \n    return routing_tables\n\ndef print_routing_tables(tables):\n    for node, table in tables.items():\n        print(f\"--- Routing Table for Node {node} ---\")\n        print(\"Dest | Next Hop | Cost\")\n        print(\"-------------------------\")\n        for dest, (next_hop, cost) in sorted(table.items()):\n            cost_str = str(cost) if cost != float('inf') else 'inf'\n            next_hop_str = next_hop if next_hop is not None else '-'\n            print(f\" {dest:^4} | {next_hop_str:^8} | {cost_str:^4}\")\n        print(\"\\n\")\n\n# Example Usage\nif __name__ == '__main__':\n    # Network graph: {node: {neighbor: cost}}\n    network = {\n        'A': {'B': 1, 'C': 7},\n        'B': {'A': 1, 'C': 2, 'D': 4},\n        'C': {'A': 7, 'B': 2, 'D': 1},\n        'D': {'B': 4, 'C': 1}\n    }\n\n    final_tables = distance_vector_routing(network)\n    print_routing_tables(final_tables)"
    },
    {
        "id": "cn-7",
        "title": "7. Data Encryption (Caesar Cipher)",
        "problem": "Implement data encryption and decryption using the Caesar Cipher.",
        "language": "python",
        "tags": ["Security", "Encryption"],
        "code": "def caesar_cipher_encrypt(text, shift):\n    \"\"\"Encrypts text using Caesar Cipher.\"\"\"\n    encrypted_text = \"\"\n    for char in text:\n        if char.isalpha():\n            start = ord('a') if char.islower() else ord('A')\n            encrypted_char = chr((ord(char) - start + shift) % 26 + start)\n            encrypted_text += encrypted_char\n        else:\n            encrypted_text += char\n    return encrypted_text\n\ndef caesar_cipher_decrypt(encrypted_text, shift):\n    \"\"\"Decrypts text from Caesar Cipher.\"\"\"\n    # Decryption is just encryption with a negative shift\n    return caesar_cipher_encrypt(encrypted_text, -shift)\n\n# Example Usage\nif __name__ == '__main__':\n    plain_text = \"Hello World! This is a secret message.\"\n    shift_key = 3\n    \n    print(f\"Original Text: {plain_text}\")\n    print(f\"Shift Key: {shift_key}\\n\")\n    \n    # Encryption\n    encrypted_message = caesar_cipher_encrypt(plain_text, shift_key)\n    print(f\"Encrypted Text: {encrypted_message}\")\n    \n    # Decryption\n    decrypted_message = caesar_cipher_decrypt(encrypted_message, shift_key)\n    print(f\"Decrypted Text: {decrypted_message}\\n\")\n    \n    print(f\"Verification: Original matches decrypted? {plain_text == decrypted_message}\")"
    },
    {
        "id": "cn-8",
        "title": "8. Leaky Bucket",
        "problem": "Write a program for congestion control using the Leaky Bucket algorithm.",
        "language": "python",
        "tags": ["Congestion Control", "Leaky Bucket"],
        "code": "import time\n\ndef leaky_bucket(packets, bucket_capacity, output_rate):\n    \"\"\"Simulates the Leaky Bucket algorithm.\"\"\"\n    storage = 0\n    \n    print(f\"Bucket Capacity: {bucket_capacity}\")\n    print(f\"Output Rate: {output_rate} packets/sec\\n\")\n    \n    for packet_size in packets:\n        print(f\"Incoming packet of size {packet_size}\")\n        \n        if packet_size + storage > bucket_capacity:\n            print(f\"  -> Packet dropped! (Overflow: {packet_size} > {bucket_capacity - storage})\")\n        else:\n            storage += packet_size\n            print(f\"  -> Packet accepted. Current storage: {storage}\")\n        \n        # Leak from the bucket at a constant rate\n        leaked_amount = min(storage, output_rate)\n        storage -= leaked_amount\n        print(f\"  -> Leaked {leaked_amount} packets. Storage is now {storage}.\")\n        \n        # Simulate time passing before the next packet arrives\n        time.sleep(1)\n        print(\"---\")\n\n# Example Usage:\nif __name__ == '__main__':\n    # A list of incoming packet sizes at each second\n    incoming_packets = [4, 6, 2, 8, 1, 5, 3]\n    BUCKET_CAPACITY = 10\n    OUTPUT_RATE = 3 # packets per second\n    \n    leaky_bucket(incoming_packets, BUCKET_CAPACITY, OUTPUT_RATE)"
    },
    {
        "id": "cn-9",
        "title": "9. Frame Sorting",
        "problem": "Write a program for a frame sorting technique used in buffers to handle out-of-order frames.",
        "language": "python",
        "tags": ["Buffering", "Sorting"],
        "code": "import random\n\nclass ReceiverBuffer:\n    def __init__(self):\n        self.buffer = {}\n        self.next_expected_frame = 0\n\n    def receive_frame(self, frame_num, data):\n        \"\"\"Receives a frame and either passes it up or buffers it.\"\"\"\n        print(f\"Receiver: Got frame {frame_num}\")\n\n        if frame_num == self.next_expected_frame:\n            # This is the frame we were waiting for\n            print(f\"  -> Frame {frame_num} is expected. Delivering to network layer.\")\n            self.deliver_to_network_layer(frame_num, data)\n            self.next_expected_frame += 1\n            \n            # Check buffer for consecutive frames\n            while self.next_expected_frame in self.buffer:\n                buffered_data = self.buffer.pop(self.next_expected_frame)\n                print(f\"  -> Frame {self.next_expected_frame} was in buffer. Delivering.\")\n                self.deliver_to_network_layer(self.next_expected_frame, buffered_data)\n                self.next_expected_frame += 1\n        elif frame_num > self.next_expected_frame:\n            # Frame arrived out of order, buffer it\n            print(f\"  -> Frame {frame_num} is out of order. Buffering.\")\n            self.buffer[frame_num] = data\n        else:\n            # Duplicate frame, discard\n            print(f\"  -> Frame {frame_num} is a duplicate. Discarding.\")\n        \n        print(f\"  Current Buffer: {sorted(self.buffer.keys())}\")\n        print(f\"  Next Expected Frame: {self.next_expected_frame}\\n\")\n\n    def deliver_to_network_layer(self, frame_num, data):\n        # In a real system, this would pass the data to the next layer up\n        pass\n\n# Example Usage:\nif __name__ == '__main__':\n    # Simulate receiving frames out of order\n    total_frames = 10\n    frames_to_send = list(range(total_frames))\n    random.shuffle(frames_to_send) # Shuffle the order of arrival\n    \n    print(f\"Simulating out-of-order frame arrival.\")\n    print(f\"Order of Arrival: {frames_to_send}\\n\")\n    \n    receiver = ReceiverBuffer()\n    \n    for frame_number in frames_to_send:\n        receiver.receive_frame(frame_number, f\"DataPayloadFor{frame_number}\")\n        \n    print(\"Simulation finished.\")\n    if not receiver.buffer:\n        print(\"All frames successfully delivered in order.\")\n    else:\n        print(f\"Frames still in buffer: {receiver.buffer.keys()}\")"
    }
]

    