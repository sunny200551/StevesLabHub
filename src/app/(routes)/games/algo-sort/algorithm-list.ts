
export type Algorithm = {
  id: number;
  name: string;
  description: string;
  steps: string[];
};

export const algorithmList: Algorithm[] = [
  {
    id: 1,
    name: 'Bubble Sort',
    description: 'A simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.',
    steps: [
      'Start a loop from the beginning of the array.',
      'In each iteration, compare the current element with the next one.',
      'If the current element is greater than the next, swap them.',
      'Repeat until the end of the array is reached.',
      'If any swaps were made, repeat the entire process.',
    ],
  },
  {
    id: 2,
    name: 'Binary Search',
    description: 'An efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing in half the portion of the list that could contain the item.',
    steps: [
      'Compare the target value with the middle element of the sorted array.',
      'If the target value matches, return its index.',
      'If the target is less than the middle element, search the left half.',
      'If the target is greater than the middle element, search the right half.',
      'Repeat the process until the value is found or the subarray is empty.',
    ],
  },
  {
    id: 3,
    name: 'Making a Peanut Butter Sandwich',
    description: 'A fundamental culinary algorithm for creating a classic sandwich.',
    steps: [
      'Get two slices of bread.',
      'Open the peanut butter jar.',
      'Use a knife to scoop some peanut butter.',
      'Spread the peanut butter on one slice of bread.',
      'Optionally, spread jelly on the other slice.',
      'Press the two slices of bread together.',
    ],
  },
  {
    id: 4,
    name: 'Selection Sort',
    description: 'An in-place comparison sorting algorithm. It has an O(nÂ²) time complexity, which makes it inefficient on large lists.',
    steps: [
      'Find the minimum element in the unsorted part of the array.',
      'Swap the found minimum element with the first element of the unsorted part.',
      'Move the boundary of the sorted and unsorted parts one element to the right.',
      'Repeat until the entire array is sorted.',
    ],
  },
  {
    id: 5,
    name: 'Insertion Sort',
    description: 'A simple sorting algorithm that builds the final sorted array one item at a time.',
    steps: [
      'Iterate from the second element to the end of the array.',
      'Take the current element (key) and compare it with the elements before it.',
      'Move elements of the sorted part that are greater than the key one position to the right.',
      'Insert the key into its correct position in the sorted part.',
    ],
  },
  {
    id: 6,
    name: 'Quick Sort',
    description: 'An efficient, divide-and-conquer sorting algorithm.',
    steps: [
      'Choose a pivot element from the array.',
      'Partition the array into two sub-arrays: elements less than the pivot and elements greater than the pivot.',
      'Place the pivot in its correct position in the sorted array.',
      'Recursively apply the same process to the sub-arrays.',
    ],
  },
  {
    id: 7,
    name: 'Merge Sort',
    description: 'A divide-and-conquer algorithm that works by recursively breaking down a problem into two or more sub-problems of the same or related type.',
    steps: [
      'Divide the unsorted list into n sublists, each containing one element.',
      'Repeatedly merge sublists to produce new sorted sublists.',
      'Continue merging until there is only one sublist remaining.',
      'The final sublist is the sorted list.',
    ],
  },
  {
    id: 8,
    name: 'Linear Search',
    description: 'A sequential search algorithm that starts at one end and goes through each element of a list until the desired element is found.',
    steps: [
      'Start from the first element of the list.',
      'Compare the current element with the target value.',
      'If the element matches, return its index.',
      'If the end of the list is reached without finding the element, return -1.',
    ],
  },
  {
    id: 9,
    name: 'Making Tea',
    description: 'A common process for preparing a hot beverage.',
    steps: [
      'Boil water in a kettle.',
      'Place a tea bag in a cup.',
      'Pour the boiling water into the cup.',
      'Let the tea steep for 3-5 minutes.',
      'Remove the tea bag.',
      'Add milk and sugar to taste.',
    ],
  },
  {
    id: 10,
    name: 'BST Insertion',
    description: 'The process of adding a new node to a Binary Search Tree while maintaining its properties.',
    steps: [
      'Start at the root of the tree.',
      'Compare the new value with the current node\'s value.',
      'If the new value is less, move to the left child.',
      'If the new value is greater, move to the right child.',
      'When you reach a null spot, insert the new node there.',
    ],
  },
  {
    id: 11,
    name: 'Stack Push Operation',
    description: 'Adding an element to the top of a stack data structure.',
    steps: [
      'Check if the stack is full.',
      'If not full, increment the top pointer.',
      'Insert the new element at the position of the top pointer.',
    ],
  },
  {
    id: 12,
    name: 'Queue Enqueue Operation',
    description: 'Adding an element to the rear of a queue data structure.',
    steps: [
      'Check if the queue is full.',
      'If not full, move the rear pointer to the next available position.',
      'Add the new element at the rear pointer\'s location.',
    ],
  },
  {
    id: 13,
    name: 'Washing Hands',
    description: 'The procedure for cleaning hands to remove germs.',
    steps: [
      'Wet your hands with clean, running water.',
      'Apply soap and lather well.',
      'Rub your hands together for at least 20 seconds.',
      'Rinse your hands thoroughly under running water.',
      'Dry your hands using a clean towel.',
    ],
  },
  {
    id: 14,
    name: 'Dijkstra\'s Algorithm',
    description: 'Finds the shortest paths between nodes in a weighted graph.',
    steps: [
      'Initialize distances to all nodes as infinite, except the source node (distance 0).',
      'Maintain a set of unvisited nodes, initially containing all nodes.',
      'Select the unvisited node with the smallest known distance and mark it as the current node.',
      'For the current node, consider all of its unvisited neighbors.',
      'Calculate the distance to each neighbor and update it if a shorter path is found.',
      'Mark the current node as visited and remove it from the unvisited set.',
      'Repeat until all nodes are visited or the destination is reached.',
    ],
  },
  {
    id: 15,
    name: 'Compiling a C++ Program',
    description: 'The steps to turn C++ source code into an executable file.',
    steps: [
      'Write the source code in a .cpp file.',
      'Run the preprocessor to expand macros and include headers.',
      'Compile the preprocessed code into assembly language.',
      'Assemble the code into an object file (.o).',
      'Link the object file with necessary libraries to create an executable.',
      'Run the final executable file.',
    ],
  },
  {
    id: 16,
    name: 'Brushing Your Teeth',
    description: 'The daily process of cleaning your teeth.',
    steps: [
      'Apply toothpaste to your toothbrush.',
      'Brush the outer and inner surfaces of your teeth.',
      'Brush the chewing surfaces.',
      'Brush your tongue to remove bacteria.',
      'Rinse your mouth with water.',
    ],
  },
  {
    id: 17,
    name: 'Depth First Search (DFS)',
    description: 'An algorithm for traversing or searching tree or graph data structures.',
    steps: [
      'Start at the root node and mark it as visited.',
      'Explore as far as possible along each branch before backtracking.',
      'Push the current node onto a stack.',
      'While the stack is not empty, pop a node and process it.',
      'Push all unvisited neighbors of the popped node onto the stack.',
    ],
  },
  {
    id: 18,
    name: 'Cooking Pasta',
    description: 'A simple method for preparing pasta.',
    steps: [
      'Fill a large pot with water and bring it to a boil.',
      'Add a generous amount of salt to the boiling water.',
      'Add the pasta to the pot.',
      'Stir occasionally to prevent sticking.',
      'Cook according to package directions until al dente.',
      'Drain the pasta using a colander.',
    ],
  },
  {
    id: 19,
    name: 'Heap Sort',
    description: 'A comparison-based sorting algorithm that uses a Binary Heap data structure.',
    steps: [
      'Build a max heap from the input data.',
      'The largest item is stored at the root of the heap.',
      'Swap the root with the last item of the heap.',
      'Reduce the size of the heap by one.',
      'Heapify the root of the tree.',
      'Repeat while size of heap is greater than 1.',
    ],
  },
  {
    id: 20,
    name: 'Making a Git Commit',
    description: 'The process of saving changes to a local Git repository.',
    steps: [
      'Make changes to your files in the working directory.',
      'Add the changes to the staging area using `git add`.',
      'Review the changes to be committed.',
      'Commit the staged changes with a descriptive message using `git commit`.',
      'Optionally, push the commit to a remote repository.',
    ],
  },
  {
    id: 21,
    name: 'Linked List Insertion',
    description: 'Adding a new node to the end of a singly linked list.',
    steps: [
      'Create a new node with the desired value.',
      'If the list is empty, set the head to the new node.',
      'If the list is not empty, traverse to the last node.',
      'Set the `next` pointer of the last node to the new node.',
    ],
  },
  {
    id: 22,
    name: 'Starting a Car (Manual)',
    description: 'The procedure for starting a car with a manual transmission.',
    steps: [
      'Ensure the handbrake is engaged.',
      'Press the clutch pedal fully to the floor.',
      'Make sure the gearshift is in the neutral position.',
      'Turn the ignition key to start the engine.',
      'Release the key once the engine starts.',
    ],
  },
  {
    id: 23,
    name: 'Breadth-First Search (BFS)',
    description: 'An algorithm for traversing graph data structures, exploring neighbors first.',
    steps: [
      'Add the starting node to a queue and mark it as visited.',
      'While the queue is not empty, dequeue a node.',
      'Process the dequeued node.',
      'Enqueue all unvisited neighbors of the processed node and mark them as visited.',
    ],
  },
  {
    id: 24,
    name: 'Making an API Request',
    description: 'The basic flow of fetching data from a web API.',
    steps: [
      'Construct the request URL with necessary parameters.',
      'Choose the appropriate HTTP method (GET, POST, etc.).',
      'Send the request to the server.',
      'Wait for and receive the server\'s response.',
      'Parse the response data (e.g., JSON).',
      'Handle any potential errors.',
    ],
  },
  {
    id: 25,
    name: 'Radix Sort',
    description: 'A non-comparative sorting algorithm for integers.',
    steps: [
      'Find the maximum number to know the number of digits.',
      'Start from the least significant digit to the most significant digit.',
      'Sort the input array using counting sort based on the current digit.',
      'Repeat for each digit.',
    ],
  },
  {
    id: 26,
    name: 'Towers of Hanoi (Recursive)',
    description: 'The classic recursive solution to the Towers of Hanoi puzzle.',
    steps: [
      'Define a function with N disks, source, auxiliary, and destination rods.',
      'Base Case: If N is 1, move the disk from source to destination.',
      'Recursive Step: Move N-1 disks from source to auxiliary rod.',
      'Move the Nth disk from source to destination rod.',
      'Recursive Step: Move N-1 disks from auxiliary to destination rod.',
    ],
  },
  {
    id: 27,
    name: 'Factorial Calculation',
    description: 'Calculating the product of all positive integers up to a given number.',
    steps: [
      'Take an integer N as input.',
      'If N is 0, the result is 1.',
      'Initialize result to 1.',
      'Loop from 1 to N.',
      'In each iteration, multiply the current result by the loop counter.',
      'Return the final result.',
    ],
  },
  {
    id: 28,
    name: 'A* Search Algorithm',
    description: 'A pathfinding algorithm known for its performance and accuracy.',
    steps: [
      'Initialize an open list and a closed list.',
      'Put the starting node on the open list (with f-cost 0).',
      'While the open list is not empty, find the node with the least f-cost.',
      'Pop the current node off the open list and add it to the closed list.',
      'Generate all neighbors of the current node.',
      'For each neighbor, if it is not on the closed list, calculate its costs and add it to the open list.',
      'Stop when you add the target node to the closed list.',
    ],
  }
];
